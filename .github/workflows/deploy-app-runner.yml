name: Deploy to AWS App Runner

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  AWS_REGION: eu-central-1
  SERVICE_NAME: idansure-app
  ECR_REPOSITORY: idansure-app
  DOTNET_VERSION: 8.0.x

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write    # for OIDC federation to AWS

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build image
        run: |
          IMAGE_TAG=${GITHUB_SHA::7}
          docker build -f SubscriptionSystem/Dockerfile -t ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG .
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Push image
        run: |
          docker push ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

      - name: Deploy / Update App Runner Service
        env:
          # Provide these via GitHub Secrets if your RDS is private or you want runtime IAM
          APPRUNNER_VPC_CONNECTOR_ARN: ${{ secrets.APPRUNNER_VPC_CONNECTOR_ARN }}
          APPRUNNER_INSTANCE_ROLE_ARN: ${{ secrets.APPRUNNER_INSTANCE_ROLE_ARN }}
        run: |
          SERVICE_ARN=$(aws apprunner list-services --query "ServiceSummaryList[?ServiceName=='${{ env.SERVICE_NAME }}'].ServiceArn" --output text)
          IMAGE_URI=${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

          # Build optional network configuration if VPC connector ARN is provided
          NETCFG=""
          if [ -n "${APPRUNNER_VPC_CONNECTOR_ARN}" ]; then
            NETCFG="--network-configuration EgressConfiguration={EgressType=VPC,VpcConnectorArn=${APPRUNNER_VPC_CONNECTOR_ARN}}"
            echo "Using App Runner VPC connector for private egress"
          else
            echo "No VPC connector ARN provided; using default public egress"
          fi

          # Build instance configuration with optional instance role ARN
          INSTANCECFG="--instance-configuration Cpu=1vCPU,Memory=2GB"
          if [ -n "${APPRUNNER_INSTANCE_ROLE_ARN}" ]; then
            INSTANCECFG="--instance-configuration Cpu=1vCPU,Memory=2GB,InstanceRoleArn=${APPRUNNER_INSTANCE_ROLE_ARN}"
            echo "Using App Runner instance role for runtime AWS access"
          fi
          if [ -z "$SERVICE_ARN" ]; then
            echo "Creating new App Runner service ${SERVICE_NAME}"
            aws apprunner create-service \
              --service-name ${{ env.SERVICE_NAME }} \
              --source-configuration ImageRepository={ImageIdentifier=$IMAGE_URI,ImageRepositoryType=ECR,ImageConfiguration={Port=8080,RuntimeEnvironmentVariables=[{Name=ASPNETCORE_ENVIRONMENT,Value=Production},{Name=EF_AUTO_MIGRATE,Value=true}]}} \
              $INSTANCECFG \
              $NETCFG \
              --auto-scaling-configuration-arn $(aws apprunner list-auto-scaling-configurations --query 'AutoScalingConfigurationSummaryList[0].AutoScalingConfigurationArn' --output text 2>/dev/null || echo '') \
              --region ${{ env.AWS_REGION }}
          else
            echo "Updating existing App Runner service"
            aws apprunner update-service --service-arn $SERVICE_ARN --source-configuration ImageRepository={ImageIdentifier=$IMAGE_URI,ImageRepositoryType=ECR,ImageConfiguration={Port=8080,RuntimeEnvironmentVariables=[{Name=ASPNETCORE_ENVIRONMENT,Value=Production},{Name=EF_AUTO_MIGRATE,Value=true}]}} $NETCFG $INSTANCECFG
          fi

      - name: Invalidate old images (optional retention)
        if: always()
        run: echo "Add lifecycle policies in ECR for image pruning as needed"
